<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Towers of Hanoi</TITLE>
<META NAME="description" CONTENT="Towers of Hanoi">
<META NAME="keywords" CONTENT="htmlatex">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="htmlatex.css">
</HEAD>
<BODY LANG="EN" BGCOLOR=#FFFFFF>
 <H1><BR CLEAR=ALL><CENTER><TABLE BGCOLOR=#0060F0><TR><TD><B><FONT SIZE=5 COLOR=#C0FFFF>&nbsp;<A NAME="SECTION0001000000000000000000">Towers of Hanoi</A></FONT>&nbsp;</B></TABLE></CENTER></H1>
<P>
In 1883, Edouard Lucas invented, or perhaps reinvented, one of the most popular
puzzles of all times - the Tower of Hanoi, as he called it - which is still
used today in many computer science textbooks to demonstrate how to write a 
recursive algorithm or program. First of all, we will make a list of the rules
of the puzzle:
<P>
<UL><LI> There are three pegs: <I>A</I>, <I>B</I> and <I>C</I>.<LI> There are <I>n</I> disks. The number <I>n</I> is constant while working the puzzle.<LI> All disks are different in size.<LI> The disks are initially stacked on peg <I>A</I> so that they increase in size
from the top to the bottom.<LI> The goal of the puzzle is to transfer the entire tower from the <I>A</I> peg
to one of the others pegs.<LI> One disk at a time can be moved from the top of a stack either to an 
empty peg or to a peg with a larger disk than itself on the top of its stack.
</UL>
<P>
A good way to get a feeling for the puzzle is to write a program which will 
show a copy of the puzzle on the screen and let you simulate moving the disks
around. The next step could be to write a program for solving the puzzle in
a eficient way. You don't have to do neither, but only know the actual 
situation after a given number of moves by using a determinate algorithm.
<P>
<H2><FONT COLOR=#0070E8><A NAME="SECTION0001001000000000000000">The Algorithm</A></FONT></H2>
<P>
It is well known and rather easy to prove that the minimum number of moves
needed to complete the puzzle with <I>n</I> disks is  <IMG WIDTH=46 HEIGHT=22 ALIGN=MIDDLE ALT="tex2html_wrap_inline44" SRC="254img1.gif"  > . A simple algorithm
which allows us to reach this optimum is as follows: for odd moves, take the
smallest disk (number 1) from the peg where it lies to the next one in the
circular sequence  <IMG WIDTH=104 HEIGHT=13 ALIGN=BOTTOM ALT="tex2html_wrap_inline46" SRC="254img2.gif"  > ; for even moves, make the only possible 
move not involving disk 1.
<P>
<H2><FONT COLOR=#0070E8><A NAME="SECTION0001002000000000000000">Input</A></FONT></H2>
<P>
The input file will consist of a series of lines. Each line will contain two
integers <I>n</I>, <I>m</I>: <I>n</I>, lying within the range [0,100], will denote the number
of disks and <I>m</I>, belonging to [0,   <IMG WIDTH=46 HEIGHT=22 ALIGN=MIDDLE ALT="tex2html_wrap_inline44" SRC="254img1.gif"  > ], will be the number of the last
move. The file will end at a line formed by two zeros.
<P>
<H2><FONT COLOR=#0070E8><A NAME="SECTION0001003000000000000000">Output</A></FONT></H2>
<P>
The output will consist again of a series of lines, one for each line of the
input. Each of them will be formed by three integers indicating the number of
disks in the pegs <I>A</I>, <I>B</I> and <I>C</I> respectively, when using the algorithm 
described above.
<P>
<H2><FONT COLOR=#0070E8><A NAME="SECTION0001004000000000000000">Sample Input</A></FONT></H2>
<P>
<PRE>3 5
64 2
8 45
0 0</PRE>
<P>
<H2><FONT COLOR=#0070E8><A NAME="SECTION0001005000000000000000">Sample Output</A></FONT></H2>
<P>
<PRE>1 1 1
62 1 1
4 2 2</PRE>
<P>
</BODY>
</HTML>
